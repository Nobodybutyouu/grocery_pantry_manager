import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hive/hive.dart';

import '../../data/models/grocery_item_model.dart';
import '../../../pantry_items/data/models/pantry_item_model.dart';
import '../state/grocery_list_state.dart';

final groceryListControllerProvider =
    NotifierProvider<GroceryListController, GroceryListState>(
  GroceryListController.new,
);

class GroceryListController extends Notifier<GroceryListState> {
  static const _boxName = 'grocery_items';
  List<GroceryItemModel> _items = [];

  @override
  GroceryListState build() {
    return const GroceryListInitial();
  }

  Future<void> loadItems() async {
    state = const GroceryListLoading();
    try {
      final box = await _openBox();
      _items = box.values.toList();
      _emitLoaded();
    } catch (error) {
      state = GroceryListError('Failed to load grocery items: $error');
    }
  }

  Future<void> addItem(GroceryItemModel item) async {
    try {
      final box = await _openBox();
      await box.put(item.id, item);
      await loadItems();
    } catch (error) {
      state = GroceryListError('Failed to add grocery item: $error');
    }
  }

  Future<void> updateItem(GroceryItemModel item) async {
    try {
      final box = await _openBox();
      await box.put(item.id, item);
      await loadItems();
    } catch (error) {
      state = GroceryListError('Failed to update grocery item: $error');
    }
  }

  Future<void> deleteItem(String id) async {
    try {
      final box = await _openBox();
      await box.delete(id);
      await loadItems();
    } catch (error) {
      state = GroceryListError('Failed to delete grocery item: $error');
    }
  }

  Future<void> toggleChecked(String id) async {
    try {
      final box = await _openBox();
      final item = box.get(id);
      if (item != null) {
        final updated = item.copyWith(
          isChecked: !item.isChecked,
          updatedAt: DateTime.now(),
        );
        await box.put(id, updated);
        await loadItems();
      }
    } catch (error) {
      state = GroceryListError('Failed to update grocery item: $error');
    }
  }

  Future<void> clearCheckedItems() async {
    try {
      final box = await _openBox();
      final checkedIds = _items.where((item) => item.isChecked).map((e) => e.id);
      await box.deleteAll(checkedIds);
      await loadItems();
    } catch (error) {
      state = GroceryListError('Failed to clear checked items: $error');
    }
  }

  Future<void> clearAllItems() async {
    try {
      final box = await _openBox();
      await box.clear();
      await loadItems();
    } catch (error) {
      state = GroceryListError('Failed to clear grocery list: $error');
    }
  }

  Future<void> generateFromPantry() async {
    try {
      state = const GroceryListLoading();
      final pantryBox = await _openPantryBox();
      final pantryItems = pantryBox.values.toList();
      final now = DateTime.now();

      final generated = pantryItems
          .where((item) => item.quantity <= 1)
          .map(
            (item) => GroceryItemModel(
              id: 'auto-${item.id}',
              name: item.name,
              quantity: item.quantity <= 0 ? 1 : item.quantity,
              category: item.category,
              isChecked: false,
              isAutoGenerated: true,
              pantryItemId: item.id,
              createdAt: now,
              updatedAt: now,
            ),
          )
          .toList();

      if (generated.isEmpty) {
        final box = await _openBox();
        _items = box.values.toList();
        _emitSuccess('No low-stock pantry items to add.');
        return;
      }

      final box = await _openBox();
      for (final item in generated) {
        await box.put(item.id, item);
      }

      _items = box.values.toList();
      _emitSuccess('Generated grocery list from pantry items.');
    } catch (error) {
      state = GroceryListError('Failed to generate grocery list: $error');
    }
  }

  void _emitLoaded() {
    final checked = _items.where((item) => item.isChecked).length;
    final unchecked = _items.length - checked;

    state = GroceryListLoaded(
      items: List.unmodifiable(_items),
      checkedCount: checked,
      uncheckedCount: unchecked,
    );
  }

  void _emitSuccess(String message) {
    final checked = _items.where((item) => item.isChecked).length;
    final unchecked = _items.length - checked;

    state = GroceryListSuccess(
      message: message,
      items: List.unmodifiable(_items),
      checkedCount: checked,
      uncheckedCount: unchecked,
    );
  }

  Future<Box<GroceryItemModel>> _openBox() async {
    if (Hive.isBoxOpen(_boxName)) {
      return Hive.box<GroceryItemModel>(_boxName);
    }
    return Hive.openBox<GroceryItemModel>(_boxName);
  }

  Future<Box<PantryItemModel>> _openPantryBox() async {
    if (Hive.isBoxOpen('pantry_items')) {
      return Hive.box<PantryItemModel>('pantry_items');
    }
    return Hive.openBox<PantryItemModel>('pantry_items');
  }
}
